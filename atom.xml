<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>~来都来了~</title>
  
  <subtitle>knothhe 的博客</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://knothhe.github.io/blog/"/>
  <updated>2019-10-28T07:44:09.000Z</updated>
  <id>http://knothhe.github.io/blog/</id>
  
  <author>
    <name>Guanglai He</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 147 链表的插入排序</title>
    <link href="http://knothhe.github.io/blog/leetcode-147-Insertion-Sort-List/"/>
    <id>http://knothhe.github.io/blog/leetcode-147-Insertion-Sort-List/</id>
    <published>2019-10-28T07:44:09.000Z</published>
    <updated>2019-10-28T07:44:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Sort a linked list using insertion sort.<br>Algorithm of Insertion Sort:</p><ol><li>Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.</li><li>At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.</li><li>It repeats until no input elements remain.</li></ol></blockquote><a id="more"></a><p>单链表的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想法：</p><p>使用两条链表，一条是已经有序的链表 A，一条是待排序的链表 B。将节点从待排序的链表 B 依次插入已经有序的链表 A。</p><p>关键点在于想到使用两条链表。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> head; &#125;</span><br><span class="line"></span><br><span class="line">        ListNode fakeHead= <span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">// because we need insert before head</span></span><br><span class="line">        ListNode cur = head; <span class="comment">// current node will be insert</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>; <span class="comment">// previous node of insert node</span></span><br><span class="line">        ListNode next = <span class="keyword">null</span>; <span class="comment">// next node of current insert node</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// save next position</span></span><br><span class="line">            next = cur.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// find insert position</span></span><br><span class="line">            pre = fakeHead;</span><br><span class="line">            <span class="keyword">while</span> (pre.next != <span class="keyword">null</span> &amp;&amp; pre.next.val &lt; cur.val) &#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// insert cur between pre and pre.next</span></span><br><span class="line">            cur.next = pre.next;</span><br><span class="line">            pre.next = cur;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// move point forward</span></span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fakeHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Sort a linked list using insertion sort.&lt;br&gt;Algorithm of Insertion Sort:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.&lt;/li&gt;
&lt;li&gt;At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.&lt;/li&gt;
&lt;li&gt;It repeats until no input elements remain.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Programming" scheme="http://knothhe.github.io/blog/categories/Programming/"/>
    
    
      <category term="LeetCode" scheme="http://knothhe.github.io/blog/tags/LeetCode/"/>
    
      <category term="Online Judge" scheme="http://knothhe.github.io/blog/tags/Online-Judge/"/>
    
      <category term="Algorithm" scheme="http://knothhe.github.io/blog/tags/Algorithm/"/>
    
      <category term="Linked List" scheme="http://knothhe.github.io/blog/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>使用 Docker 创建 MySQL 实验环境</title>
    <link href="http://knothhe.github.io/blog/create-a-mysql-lab-using-docker/"/>
    <id>http://knothhe.github.io/blog/create-a-mysql-lab-using-docker/</id>
    <published>2019-09-26T11:42:09.000Z</published>
    <updated>2021-04-01T18:30:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于有学习 MySQL 的需求，但是又不想破坏本地的 MySQL(MariaDB)，于是想到了使用 Docker 来创建符合需求的 MySQL 实验环境。<br>并且通过官方(?)提供的测试数据创建用于测试使用的数据库。</p><p>本文默认读者已安装好 Docker 及本地 MySQL。</p><a id="more"></a><h2 id="拉取已有的-MySQL-Docker-镜像。"><a href="#拉取已有的-MySQL-Docker-镜像。" class="headerlink" title="拉取已有的 MySQL Docker 镜像。"></a>拉取已有的 MySQL Docker 镜像。</h2><p>使用下面的命令搜索可用的 mysql：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><p>可以看到类似下面的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">mysql                             MySQL is a widely used, open-source relation…   8621                [OK]</span><br><span class="line">mariadb                           MariaDB is a community-developed fork of MyS…   2997                [OK]</span><br><span class="line">mysql/mysql-server                Optimized MySQL Server Docker images. Create…   637                                     [OK]</span><br><span class="line">centos/mysql-57-centos7           MySQL 5.7 SQL database server                   63</span><br></pre></td></tr></table></figure><p>使用下面的命令拉取第一个官方镜像的最新版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure><h2 id="创建并运行-Docker-容器中的-MySQL"><a href="#创建并运行-Docker-容器中的-MySQL" class="headerlink" title="创建并运行 Docker 容器中的 MySQL"></a>创建并运行 Docker 容器中的 MySQL</h2><p>使用下面的命令运行和配置刚刚拉取的 Docker 镜像：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql-lab -p 3307:3306 -e MYSQL_ROOT_PASSWORD=password -d mysql</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>--name TEXT</code> 表示创建的镜像的名称，如果不提供该参数，则 docker 会随机生成一个名称。该示例中创建的名称为 mysql-lab</li><li><code>-e TEXT</code> 表示提供的环境变量的键值对。此处提供一个名为 MYSQL_ROOT_PASSWORD 的环境变量，其值为 password</li><li><code>-d</code> 表示在后台运行该容器</li><li><code>-p</code> 指定容器外端口到容器内端口的映射，3307 为容器外端口，3306 为容器内端口，即 MySQL 默认运行端口。指定后，即可在容器外通过 <code>localhost</code> 地址加上 3307 端口连接到容器内的 MySQL。就如同操作本地安装的 MySQL 一样，而不需要进行下方的容器外连接 MySQL 的操作。</li></ul><h2 id="检查容器的运行状态"><a href="#检查容器的运行状态" class="headerlink" title="检查容器的运行状态"></a>检查容器的运行状态</h2><p>使用下面的命令检查：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>可以类似下面的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                           NAMES</span><br><span class="line">c046b3491396        mysql               &quot;docker-entrypoint.s…&quot;   4 hours ago         Up 4 hours          3306/tcp, 33060/tcp                             mysql-lab</span><br></pre></td></tr></table></figure><h2 id="连接-Docker-中的-MySQL"><a href="#连接-Docker-中的-MySQL" class="headerlink" title="连接 Docker 中的 MySQL"></a>连接 Docker 中的 MySQL</h2><ul><li><p>直接进入容然后进入 MySQL 命令行</p><p>  可以使用下面的命令直接进入 Docker 容器中然后连接该容器中的 MySQL：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql-lab bash</span><br></pre></td></tr></table></figure><p>  进入容器后，和在本地中使用类似，使用下面的命令即可进入 MySQL 命令行:</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>  密码为先前设置的 <code>password</code></p></li><li><p><del>从容器外连接 MySQL</del> <strong>可直接指定端口映射从容器外连接 MySQL</strong></p><p>  更好的方法是在容器外连接 MySQL。</p><ol><li><p>首先使用下面的命令查找出刚刚创建的 Docker 镜像的地址：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect mysql-lab | grep IPAddress</span><br></pre></td></tr></table></figure><p>可以看到如下的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;IPAddress&quot;: &quot;172.17.0.2&quot;</span><br></pre></td></tr></table></figure></li><li><p>根据刚刚查找出的地址连接 MySQL 数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -h 172.17.0.2 -P 3306 -p</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="导入测试数据"><a href="#导入测试数据" class="headerlink" title="导入测试数据"></a>导入测试数据</h2><ol><li><p>下载测试数据</p><p> <a href="https://github.com/datacharmer/test_db" target="_blank" rel="noopener">测试数据地址</a></p></li><li><p>按照地址中的 <code>README</code> 进行操作即可。下方操作只导入了数据库模型，并未导入实际的数据。且指定端口后不再需要类似下方的操作。</p></li><li><p>进入到下载的测试数据的目录下</p></li><li><p>导入到数据库中</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -h 172.17.0.2 -P 3306 -p &lt; employees.sql</span><br></pre></td></tr></table></figure></li><li><p>测试导入的数据完整性</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -h 172.17.0.2 -P 3306 -p -t &lt; test_employees_md5.sql</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于有学习 MySQL 的需求，但是又不想破坏本地的 MySQL(MariaDB)，于是想到了使用 Docker 来创建符合需求的 MySQL 实验环境。&lt;br&gt;并且通过官方(?)提供的测试数据创建用于测试使用的数据库。&lt;/p&gt;
&lt;p&gt;本文默认读者已安装好 Docker 及本地 MySQL。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://knothhe.github.io/blog/categories/Tools/"/>
    
    
      <category term="Docker" scheme="http://knothhe.github.io/blog/tags/Docker/"/>
    
      <category term="MySQL" scheme="http://knothhe.github.io/blog/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>使用 Hexo + GitHub 搭建博客</title>
    <link href="http://knothhe.github.io/blog/hexo-and-github-build-blog/"/>
    <id>http://knothhe.github.io/blog/hexo-and-github-build-blog/</id>
    <published>2019-09-23T01:14:57.000Z</published>
    <updated>2019-09-28T13:40:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为不止有一个同学问过我如何借助 GitHub 搭建博客，是决定把搭建博客的整个流程记录下来，<br>以供想要自己借助 Hexo 和 GitHub 搭建博客的同学参考。<br>我主要使用 Hexo 生成静态站点文件，然后　push 到 GitHub 上借助 GitHub Pages 展示静态博客。</p><a id="more"></a><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>在安装 <code>Hexo</code> 之前，首先需要先安装 <code>Node.js</code> 和 <code>Git</code>。</p><ol><li>安装 <code>Node.js</code> 和　<code>Npm</code></li></ol><ul><li>最简单的方式就是到 <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.js download page</a> 直接下载安装。</li></ul><ol start="2"><li>安装并配置 Git</li></ol><ul><li><p>安装 Git</p><p>  到 <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git Download page</a> 根据所用的操作系统下载并安装 Git</p></li><li><p>配置 Git</p><p>  在使用 Git 之前，需要先配置 Git 的用户名和用户邮箱</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"your name"</span></span><br><span class="line">git config --global user.email youremail@example.com</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><p>安装 Hexo</p><p> 使用 Npm 安装 Hexo。</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用-Hexo"><a href="#使用-Hexo" class="headerlink" title="使用 Hexo"></a>使用 Hexo</h2><p>使用下面的命令初始化目标文件夹，所有需要的文件都会被下载到该文件夹下。<br>这个过程需要一段时间。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>初始化之后就可使用如下命令预览，默认已经有一篇 Hello World 文档用于预览效果的展示。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>可以看到命令行有提示，Hexo 运行在地址 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>，通过浏览器打开该网址即可看到预览结果。</p><h2 id="博客编写"><a href="#博客编写" class="headerlink" title="博客编写"></a>博客编写</h2><p>所有的文档的编写都需要放在 <code>source/_posts</code> 目录下，初始化后可以看到该目录下有一个 <code>hello-world.md</code>，同样，我们需要写的文档也类似。</p><p>简单使用 <a href="https://www.markdownguide.org/basic-syntax" target="_blank" rel="noopener">Markdown 的指导</a></p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><ol><li><p>在你的 GitHub 账户下创建一个仓库用于存放 Hexo 生成的静态文件。GitHub Page 会根据仓库名给定一个对应的域名。假定用户名为 username，规则如下:</p><ol><li>如果仓库名为 <code>username.github.io</code>，则对应的域名为 <code>username.github.io</code></li><li><p>如果是其他名字，如 <code>theBlogRepository</code>，则对应的域名为 <code>username.github.io/theblogrepository</code></p><p>比如，我的 GitHub 用户名为 <a href="https://github.com/KnothHe" target="_blank" rel="noopener">knothhe</a>，我存放博客的仓库名为 <code>blog</code>，我的博客地址就是 <a href="https://knothhe.github.io/blog">https://knothhe.github.io/blog</a>。</p><p>最后在该仓库的设置页面需要开启 GitHub Page 的选项，默认有 master 分支和 master 分支下的 /docs 文件夹。选择 master 分支即可。</p></li></ol></li><li><p>配置 <code>_config.yml</code></p><ul><li><p>可以看到该文件默认有 deploy 小节，由于是发布到 GitHub，那么按下面配置编写即可:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">    repo:</span></span><br><span class="line"><span class="attr">        github:</span> <span class="string">git@github.com:yourGitHubUsername/theBlogRepository.git</span></span><br><span class="line"><span class="attr">    branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>安装 Hexo 使用 Git 发布的插件</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>使用下面的命令发布到你的 GitHub 仓库</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d g</span><br></pre></td></tr></table></figure></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>详细的使用和指导可以参考 <a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo 的文档</a>。</p><p>已经有很多人写过类似的文章了，通过 google 或者 baidu 搜索下面的关键词即可得到很多的详细教程。</p><p>搜索关键字: <code>hexo github 个人博客</code></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><code>Git</code> 官网的<a href="https://git-scm.com/book/en/v2/Getting-Started-First-Time-Git-Setup" target="_blank" rel="noopener">配置指导</a></li><li><code>Git</code> 官网的<a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git" target="_blank" rel="noopener">安装指导</a></li><li><code>Npm</code> 官网的<a href="https://docs.npmjs.com/downloading-and-installing-node-js-and-npm#os-x-or-windows-node-installers" target="_blank" rel="noopener">安装指导</a></li><li><code>Hexo</code> 官网的<a href="https://hexo.io/docs/index.html" target="_blank" rel="noopener">安装指导</a></li><li><code>Hexo</code> 官网的<a href="https://hexo.io/docs/setup" target="_blank" rel="noopener">使用指导</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为不止有一个同学问过我如何借助 GitHub 搭建博客，是决定把搭建博客的整个流程记录下来，&lt;br&gt;以供想要自己借助 Hexo 和 GitHub 搭建博客的同学参考。&lt;br&gt;我主要使用 Hexo 生成静态站点文件，然后　push 到 GitHub 上借助 GitHub Pages 展示静态博客。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://knothhe.github.io/blog/categories/Tools/"/>
    
    
      <category term="Hexo" scheme="http://knothhe.github.io/blog/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX 实现简单的条件编译</title>
    <link href="http://knothhe.github.io/blog/latex-conditional-compilation/"/>
    <id>http://knothhe.github.io/blog/latex-conditional-compilation/</id>
    <published>2019-09-23T00:10:52.000Z</published>
    <updated>2021-08-15T04:57:51.233Z</updated>
    
    <content type="html"><![CDATA[<p>我想让 LaTeX 支持的条件编译的功能是：</p><p>根据我是否定义某个具体的宏变量，决定是否编译某一片段。</p><p>通过简单搜索之后，了解到一个简单的宏包 <code>ifthen</code> 即可实现此功能，现将实现方法记录如下。</p><a id="more"></a><p>TLDR:</p><ol><li>引入 <code>ifthen</code> 宏包。</li><li>使用 <code>\ifthenelse{\isundefine{\themarco}}{〈then clause〉}{〈else clause〉</code> 命令</li><li>通过 <code>xelatex &quot;\def\themarco{1} &quot;\input{filename.tex}&quot;</code> 在编译时定义宏。</li></ol><h2 id="引入-ifthen-宏包"><a href="#引入-ifthen-宏包" class="headerlink" title="引入 ifthen 宏包"></a>引入 <code>ifthen</code> 宏包</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;ifthen&#125;</span></span></span><br></pre></td></tr></table></figure><h2 id="使用-ifthenelse"><a href="#使用-ifthenelse" class="headerlink" title="使用 \ifthenelse{}{}{}"></a>使用 <code>\ifthenelse{}{}{}</code></h2><p>根据文档，　<code>\ifthenelse{〈test〉}{〈then clause〉}{〈else clause〉</code>　的定义如下：</p><p>如果 test 为真，则包括 <code>&lt;then clause&gt;</code>，否则包括 <code>&lt;else clause&gt;</code>。</p><p><code>&lt;test&gt;</code> boolean 表达式可以以 <code>\and</code>、<code>\or</code>、<code>\not</code> 连接，此处我只需要测试一个宏是否定义，则不需要。</p><p>文档中还写到，可以使用 <code>\isundefined{}</code> 来测试一个具体的宏是否未定义。虽然我更想找到一个宏可以判断一个变量是否被定义，但是，好吧，这个宏也能完成我需要的功能。</p><p>所以，完成的语句如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">ifthenelse</span><span class="string">&#123;\isundefined&#123;\themacro&#125;</span></span>&#125;&#123;</span><br><span class="line">    &lt;then clause&gt;</span><br><span class="line">&#125;&#123;</span><br><span class="line">    &lt;else clause&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果　<code>\themacro</code> 未定以，则执行（包括） <code>&lt;then clause&gt;</code>，否则执行 <code>&lt;else clause&gt;</code>。</p><p>至此，在 <code>tex</code> 文档中需要做的工作已经完成。接下来我们需要知道的是如何使用命令行编译时定义某个具体的宏。幸好，这个问题也很好解决。</p><h2 id="在使用编译命令时定义具体的宏"><a href="#在使用编译命令时定义具体的宏" class="headerlink" title="在使用编译命令时定义具体的宏"></a>在使用编译命令时定义具体的宏</h2><p>以 <code>xelatex</code> 为例，我们可以直接输入以下命令编译指定文件。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xelatex filename.tex</span><br></pre></td></tr></table></figure><p>同时如果输入参数不是文件名，而是字符串的话，同样可以编译。即 <code>xelatex &quot;string&quot;</code> 同样可以通过编译并生成文件，默认的文件名是 <code>texput.pdf</code>。目前，我仍然不知道 <code>xelatex</code> 如何指定输出文件名。</p><p>于是，我们可以通过以下命令定义我们需要的宏。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xelatex "<span class="tag">\<span class="name">def</span></span><span class="tag">\<span class="name">thenmarco</span><span class="string">&#123;1&#125;</span></span> <span class="tag">\<span class="name">input</span><span class="string">&#123;filename.tex&#125;</span></span>"</span><br></pre></td></tr></table></figure><p>至此，我所需要的条件编译的功能得到满足。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="http://mirrors.ctan.org/macros/latex/base/ifthen.pdf" target="_blank" rel="noopener">ifthen 宏包文档</a></li><li><a href="https://tex.stackexchange.com/a/1495" target="_blank" rel="noopener">如何通过命令行定义 LaTeX 变量的 SO 回答</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我想让 LaTeX 支持的条件编译的功能是：&lt;/p&gt;
&lt;p&gt;根据我是否定义某个具体的宏变量，决定是否编译某一片段。&lt;/p&gt;
&lt;p&gt;通过简单搜索之后，了解到一个简单的宏包 &lt;code&gt;ifthen&lt;/code&gt; 即可实现此功能，现将实现方法记录如下。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://knothhe.github.io/blog/categories/Tools/"/>
    
    
      <category term="LaTeX" scheme="http://knothhe.github.io/blog/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>广州百田 2019 笔试题</title>
    <link href="http://knothhe.github.io/blog/guangzhou-baitian-written-test/"/>
    <id>http://knothhe.github.io/blog/guangzhou-baitian-written-test/</id>
    <published>2019-09-22T14:05:54.000Z</published>
    <updated>2019-09-26T02:23:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>趁着秋招，因为同学的推荐，投递了广州百田。这两天百田发送邮件，通知线上笔试。内容摘要如下：</p><blockquote><p>百奥（广州百田）邀请您参加线上笔试，试卷名称是： 开发工程师-百奥2020届校园招聘笔试（笔试题根据网申岗位而定）<br>请务必在试卷开放时间 2019-09-21 9:00:00 至 2019-09-23 21:00:00 完成答卷，<br>请复制下方的试卷链接到浏览器中作答。（Web前端、游戏前端、Java后端开发均为同一套题）<br>(链接地址)<br>祝福：信心是成功的一半，祝您考试顺利！</p></blockquote><p>笔试题总共有三道，都是非常基础的题目，现记录如下。</p><a id="more"></a><p>注 1: 百田笔试题给定的某些题目描述是 C++，某些是 Java，而且答题语言不限。<br>我提供的题目和答案则都是 C++ 描述。</p><p>注 2: 在和同学讨论后，我们一致认为百田的线上笔试有漏洞。首先，和同学讨论过后得知，我们的测试题目相同。</p><p>从发送的邮件内容：</p><blockquote><p>（Web前端、游戏前端、Java后端开发均为同一套题）</p></blockquote><p>也可得知，统一批次的线上笔试题应该相同。那么如果有两个认识的人参加同一轮线上笔试，<br>并且在不同时间点做题，那么先做的那个人就可以知道题目，然后就可以告知后做的人。<br>那么，后做题的人就可先行准备。因为我和同学是同时开始答题，则无法利用此漏洞。<br>当然，我们也并不打算利用此漏洞，只是觉得有必要说明一下。</p><p>注 3: 貌似不同批次的题目是不一样的，所以只有同一批次的应聘者的笔试题目才是相同的。<br>所以为什么不把笔试时间固定，而是在一个时间范围内？</p><h2 id="分割链表"><a href="#分割链表" class="headerlink" title="分割链表"></a>分割链表</h2><p>假定有一个链表，编写一个函数，将该按如下规则分成三个链表。</p><p>首先，给定的节点定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> content;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然后，规则如下：</p><ol><li>如果该节点的 content 为大写字母，则插入第一条链表。</li><li>如果该节点的 content 为数字，则插入第二条链表。</li><li>其他则插入第三条链表。</li></ol><p>最后，需要完成的函数定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node*&gt; split(Node *head);</span><br></pre></td></tr></table></figure><p>题解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Node*&gt; split(Node *head) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt; curs(<span class="number">3</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt; heads(<span class="number">3</span>, <span class="literal">NULL</span>);</span><br><span class="line">    Node *cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Node *next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">char</span> c = cur-&gt;content;</span><br><span class="line">        <span class="keyword">int</span> which = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>) &#123;</span><br><span class="line">            which = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">            which = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curs[which] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            curs[which] = cur;</span><br><span class="line">            heads[which] = curs[which];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curs[which]-&gt;next = cur;</span><br><span class="line">            curs[which] = curs[which]-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heads;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> content;</span><br><span class="line">    Node *next;</span><br><span class="line">    Node(<span class="keyword">char</span> c) : content(c), next(<span class="literal">NULL</span>) &#123;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_nodes</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    Node *cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cur-&gt;content;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"A233CD@#SD2"</span>;</span><br><span class="line">    Node *head = <span class="keyword">new</span> Node(s[<span class="number">0</span>]);</span><br><span class="line">    Node *cur = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">        cur-&gt;next = <span class="keyword">new</span> Node(s[i]);</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt; curs = split(head);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curs.size(); i++) &#123;</span><br><span class="line">        print_nodes(curs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打乱数组"><a href="#打乱数组" class="headerlink" title="打乱数组"></a>打乱数组</h2><p>注： 题目给定的应该是 Java 形式的函数定义，为 <code>void shuffle(int[] orderArray)</code></p><p>给定一个数组，打乱该数组。</p><p>需要完成的函数定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; orderArray)</span></span>;</span><br></pre></td></tr></table></figure><p>提供一个生成随机数的函数 <code>rand(min, max)</code> 返回值为 <code>[min, max)</code> 之间的一个整数。</p><p>题解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;orderArray)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = orderArray.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = rand(i, len);</span><br><span class="line">        <span class="keyword">int</span> t = orderArray[r];</span><br><span class="line">        orderArray[r] = orderArray[i];</span><br><span class="line">        orderArray[i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rand(min, max) rand() % (max - min) + min</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; orderArray(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; orderArray.size(); i++) &#123;</span><br><span class="line">        orderArray[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    shuffle(orderArray);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; orderArray.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; orderArray[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算前缀表达式的值"><a href="#计算前缀表达式的值" class="headerlink" title="计算前缀表达式的值"></a>计算前缀表达式的值</h2><p>给定一个以前缀表达式表示的字符串，计算其结果。</p><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-*+1234</span><br></pre></td></tr></table></figure></p><p>等价于下面的中缀表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1 + 2) * 3 - 4</span><br></pre></td></tr></table></figure></p><p>其结果为 5。</p><p>给定的函数定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eval</span><span class="params">(<span class="built_in">string</span> <span class="built_in">exp</span>)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eval</span><span class="params">(<span class="built_in">string</span> <span class="built_in">exp</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">exp</span>.size();</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = <span class="built_in">exp</span>[i];</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">            st.push(c-<span class="string">'0'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> a = st.top(); st.pop();</span><br><span class="line">            <span class="keyword">int</span> b = st.top(); st.pop();</span><br><span class="line">            <span class="keyword">int</span> r;</span><br><span class="line">            <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                    r = a + b;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                    r = a - b;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                    r = a * b;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// (1 + 2) * 3 - 4 = 5</span></span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">exp</span> = <span class="string">"-*+1234"</span>;</span><br><span class="line">    <span class="keyword">int</span> val = calc(<span class="built_in">exp</span>);</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"test pass\n"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"test fail\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p><strong>题目解析等之后再弄，今天有点晚了。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;趁着秋招，因为同学的推荐，投递了广州百田。这两天百田发送邮件，通知线上笔试。内容摘要如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;百奥（广州百田）邀请您参加线上笔试，试卷名称是： 开发工程师-百奥2020届校园招聘笔试（笔试题根据网申岗位而定）&lt;br&gt;请务必在试卷开放时间 2019-09-21 9:00:00 至 2019-09-23 21:00:00 完成答卷，&lt;br&gt;请复制下方的试卷链接到浏览器中作答。（Web前端、游戏前端、Java后端开发均为同一套题）&lt;br&gt;(链接地址)&lt;br&gt;祝福：信心是成功的一半，祝您考试顺利！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;笔试题总共有三道，都是非常基础的题目，现记录如下。&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="http://knothhe.github.io/blog/categories/Programming/"/>
    
    
      <category term="Interview" scheme="http://knothhe.github.io/blog/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下 VS Code 的 C/C++ 调试器使用</title>
    <link href="http://knothhe.github.io/blog/vscode-linux-debugger-launch/"/>
    <id>http://knothhe.github.io/blog/vscode-linux-debugger-launch/</id>
    <published>2019-09-05T00:19:05.000Z</published>
    <updated>2021-08-15T04:57:51.233Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来，我在 Linux 下的 VS Code 的启动调试器都存在无法调试需要获取用户输入的程序，昨天总算是把这个问题解决了。</p><p>tldr: 在 Linux 下不要用 lldb，用 gdb，具体原因不清楚，但是我被坑了。</p><a id="more"></a><h2 id="launch-json-和-task-json"><a href="#launch-json-和-task-json" class="headerlink" title="launch.json 和 task.json"></a>launch.json 和 task.json</h2><p>VS Code 下启动调试器需要依赖文件夹根目录下的 .vsocde/launch.json 文件，该目录及其子目录的调试器的行为都可以通过在该文件中配置选项来指定。最简单的创建 launch.json 文件的方法是在需要调试的源程序标签页中点击左边 Activity Bar 上的调试器的按钮，当没有 launch.json 文件时，VS Code 会提示根据模板创建 launch.json 文件。然后回到源程序标签下，启动刚刚创建的 launch.json，由于没有生成可调试的可执行文件，需要生成 .vscode/task.json 预先编译源文件生成可调试的可执行文件。正常情况下，接下来应该就可以进行调试。但是在 Manjaro 下使用是我遇到了以下问题。</p><h2 id="externalConsole-选项-默认外部终端的坑"><a href="#externalConsole-选项-默认外部终端的坑" class="headerlink" title="externalConsole 选项/默认外部终端的坑"></a>externalConsole 选项/默认外部终端的坑</h2><p>根据 vscode-cpptools 的这个 <a href="https://github.com/microsoft/vscode-cpptools/issues/2998" target="_blank" rel="noopener">issue</a> 中线索，当设置 externalConsole 为 true 时，在 Linux 下，调试器会完全无法启动。设置为 false，则可以启动，但是无法获用户输入（后来证实是我遇到的另一个坑）。</p><p>仔细阅读该 issue 可以发现，关键在于 VS Code 的调试器在启动时，如果该选项设置为 true，则 VS Code 会根据 terminal.external.linuxExec 推断在 Linux 下应该启动的默认的 Terminal，并且该选项的默认值为 xterm。但是我的系统上并没有安装 xterm，所以在启动调试器后一直卡顿在这一步。于是安装 xterm。然后调试器正常启动。</p><h2 id="gdb-vs-lldb"><a href="#gdb-vs-lldb" class="headerlink" title="gdb vs lldb"></a>gdb vs lldb</h2><p>开始时我使用的调试器是 lldb，一切都很正常，唯有在读取用户输入时，无论是内部终端还是外部终端，都无法成功。于是切换到 gdb，成功。从这儿就能感觉到 llvm 在 Linux 下的支持还是不如 gcc，虽然我很喜欢或者说更偏向 clang/llvm。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>有意思的是，我刚刚引用的那个 issue 是唯一被标记的 issue，可见被坑的人应该不在少数 ;p</p><p><img src="/blog/vscode-linux-debugger-launch/vscode-cpptools-pinned-issue.png" alt="唯一标记的 issue"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来，我在 Linux 下的 VS Code 的启动调试器都存在无法调试需要获取用户输入的程序，昨天总算是把这个问题解决了。&lt;/p&gt;
&lt;p&gt;tldr: 在 Linux 下不要用 lldb，用 gdb，具体原因不清楚，但是我被坑了。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://knothhe.github.io/blog/categories/Tools/"/>
    
    
      <category term="VS Code" scheme="http://knothhe.github.io/blog/tags/VS-Code/"/>
    
      <category term="Linux" scheme="http://knothhe.github.io/blog/tags/Linux/"/>
    
      <category term="C/C++" scheme="http://knothhe.github.io/blog/tags/C-C/"/>
    
      <category term="Debugger" scheme="http://knothhe.github.io/blog/tags/Debugger/"/>
    
  </entry>
  
  <entry>
    <title>IEEE 浮点数表示</title>
    <link href="http://knothhe.github.io/blog/ieee-floating-point-representation/"/>
    <id>http://knothhe.github.io/blog/ieee-floating-point-representation/</id>
    <published>2019-05-17T07:52:25.000Z</published>
    <updated>2021-08-15T04:57:51.233Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来都不能非常清楚地记住浮点数的表示方式，这段时间开始重读 CSAPP 的第二章中浮点数表示的部分，大致上弄清楚了 IEEE 浮点数的表示方式。</p><p>简单介绍一下 IEEE 浮点数的表示方式，细节部分可以参考 CSAPP 和 <a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">维基</a></p><a id="more"></a><h2 id="二进制小数表示"><a href="#二进制小数表示" class="headerlink" title="二进制小数表示"></a>二进制小数表示</h2><p>首先理解一下十进制小数的表示方式，我们以下面这种方式表示十进制小数：</p><p>$$<br>    d_{n}d_{n-1}…d_{1}d_{0}.d_{-1}…d_{m}<br>$$</p><p>表示的值为：</p><p>$$<br>    \sum_{i = m}^{n} 10^{i}d_{i}<br>$$</p><p>类似地，二进制小数的表示方式：</p><p>$$<br>    b_{n}b_{n-1}…b_{1}b_{0}.b_{-1}…b_{m}<br>$$</p><p>$$<br>    \sum_{i = m}^{n} 2^{i}b_{i}<br>$$</p><p>例如二进制小数</p><p>$$<br>11.01_2 = 1 \times 2^{1} + 1 \times 2^{0} + 0 \times 2^{-1} + 1 \times 2^{-2}<br>    = 2 + 1 + 0 + 0.25<br>    = 3.25<br>$$</p><p>现在考虑如何对这种二进制小数进行编码，一种可行的方式是定点小数。即将小数点的位置固定。例如使用 16 位二进制数来编码定点小数。可以做如下规定：</p><ol><li>第 15 位为符号位。</li><li>第 14 ~ 9 位表示小数点前的数</li><li>第 8 ~ 0 位表示小数点后的数</li></ol><p>那么，$11.01$ 可以编码为 $0 000011 010000000$。</p><p>这种表示方式的优点是比较简单，但是能够表示的小数的范围就十分的小。不考虑小数点后的数字，这种方式能够表示的整数范围就只能是 $-2^{6}+1 \sim 2^{6} - 1$。</p><p>于是，考虑到不去固定小数点的位置。而是根据当前的数字来确定小数点的具体位置。这样，就有了一种新的表示小数的方式，即浮点数。以下面这种方式表示（不考虑编码方式）：</p><p>$$<br>    V = (-1)^s \times M \times 2^{E}<br>$$</p><p>其中，$s$ 表示符号位，$E$ 表示阶码，$M$ 表示尾数。</p><p>通过这种方式，就有了 IEEE 754 浮点数规范。其具体定义了浮点数的位级编码规则。</p><h2 id="IEEE-浮点数表示"><a href="#IEEE-浮点数表示" class="headerlink" title="IEEE 浮点数表示"></a>IEEE 浮点数表示</h2><p>首先， IEEE 将浮点数编码为 32 位或者 64 位。其中，32 位的规则如下：</p><ol><li>第 32 位表示符号</li><li>第 31 ~ 23 位表示的值为 $E$，其位级表示记为 $exp$</li><li>第 22 ~ 0 位表示的值 $M$, 其位级表示记为 $frac$</li></ol><p>64 位编码表示中，$exp$ 长度为 11，$frac$ 长度为 52。与 32 位类似。</p><p>根据 $exp$ 和 $frac$ 的表示的不同，IEEE 浮点数规范将浮点数分为 4 类：</p><ol><li>规格化数： $exp$ 不为全 0 和全 1</li><li>非规格化数： $exp$ 为全 0</li><li>无穷大： $exp$ 为全 1 且 $frac$ 为全 0</li><li>$NAN$： $exp$ 为全 1 且 $frac$ 不为全 0</li></ol><h3 id="规格化数"><a href="#规格化数" class="headerlink" title="规格化数"></a>规格化数</h3><p>首先 $E = e - Bias$, 其中 $e$ 为 $exp$ 所表示的无符号数。$Bias$ 的值为 $2^{k-1}-1$，$k$ 为 $frac$ 部分的长度。例如，32 位编码时 $k$ 的值为 $8$，于是 $Bias$ 的值为 $127$，最终， $E$ 的范围为 $-126 \sim 127$。</p><p>其次 $M = 1 + f$，其中 $f$ 为 $0.f_{n}f_{n-1}…f_{0}$ 所表示的值。这里，通过将 $f$ 加 1 获得了一个额外的表示精度位。</p><h3 id="非规格化数"><a href="#非规格化数" class="headerlink" title="非规格化数"></a>非规格化数</h3><p>其 $E = 1 - Bias$，而 $M = f$。</p><p>根据该定义，当 $frac$ 为全 0 时， $M = 0$。于是：</p><p>$$<br>    V = (-1)^s \times E \times 0 = 0<br>$$</p><p>根据 $s$ 的值的不同，得到了表示 0 的两种方式，记为 $+0$ 和 $-0$。</p><h3 id="无穷大"><a href="#无穷大" class="headerlink" title="无穷大"></a>无穷大</h3><p>根据符号位分为 $+\infty$ 和 $-\infty$。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般来说，非规格化数用于表示 $0$ 和非常接近 $0$ 的数。而相对其他能正常表示的数则用规格化数表示，溢出的值则用无穷大表示。当溢出的小数部分为非 $0$ 即可用 $NAN$（Not A Number)表示。当一些运算的结果不是实数或者无穷时，就会返回 $NAN$，比如 $\sqrt{-1}$。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>写技术文章需要严谨、正确，可能我比没有做到。所有如果有疑惑的话，可以学习一下 CSAPP 中和此有关的内容。</p><!-- 我后悔写这篇博客了，描述好一个规范并不是一件容易的事。想要讲的正确且生动就更加不容易了。但是因为已经写了，于是还是决定放出来。以后如果再打算写类似的博客一定会仔细考虑考虑。而且，实际上 CSAPP 上的这一小节讲述的已经足够清楚了。 -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来都不能非常清楚地记住浮点数的表示方式，这段时间开始重读 CSAPP 的第二章中浮点数表示的部分，大致上弄清楚了 IEEE 浮点数的表示方式。&lt;/p&gt;
&lt;p&gt;简单介绍一下 IEEE 浮点数的表示方式，细节部分可以参考 CSAPP 和 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;维基&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Computer" scheme="http://knothhe.github.io/blog/categories/Computer/"/>
    
    
      <category term="IEEE 754" scheme="http://knothhe.github.io/blog/tags/IEEE-754/"/>
    
      <category term="Floating Point" scheme="http://knothhe.github.io/blog/tags/Floating-Point/"/>
    
      <category term="CSAPP" scheme="http://knothhe.github.io/blog/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>初次笔试题</title>
    <link href="http://knothhe.github.io/blog/interview-first-time/"/>
    <id>http://knothhe.github.io/blog/interview-first-time/</id>
    <published>2019-05-09T02:57:00.000Z</published>
    <updated>2019-05-11T05:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天参加了学校的一个企业实习的宣讲会，结束后做了笔试题。签到时我选择的应聘岗位是后端开发，但是在选择笔试试卷是选择了 C/C++ 开发。和编程相关的题目总共是 4 道题。现场做题的时候有很多的细节没有考虑到，而且我更习惯使用电脑写代码，没有多少在纸上写代码的经历，最后只写了 3 道，一道空白。就个人感觉，这些笔试题中有一道题并不适合笔试。最后，最重要的是很基础的题目我并没有能够做到 bug-free。编程的基础还需要继续巩固。特记录如下。</p><a id="more"></a><p>题目记录如下：</p><h2 id="C-语言-strcat-的实现"><a href="#C-语言-strcat-的实现" class="headerlink" title="C 语言 strcat 的实现"></a>C 语言 <code>strcat</code> 的实现</h2><p>和库函数 <code>strcat</code> 并不相同，声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* a, <span class="keyword">const</span> <span class="keyword">char</span>* b)</span></span></span><br></pre></td></tr></table></figure><p>大致的思路是先计算出 a 和 b 的长度，然后根据 a 和 b 的长度计算出需要分配给返回字符串的内存空间的大小，最后将 a 和 b 的内容依次拷贝到返回字符串中。</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcat_m</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* a, <span class="keyword">const</span> <span class="keyword">char</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> aLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; a[aLen] != <span class="string">'\0'</span>; ++aLen) &#123;</span><br><span class="line">        ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b[bLen] != <span class="string">'\0'</span>; ++bLen) &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = aLen + bLen;</span><br><span class="line">    <span class="keyword">char</span>* str = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (len+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">char</span>* p = str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; aLen; ++i) &#123;</span><br><span class="line">        *p = a[i];</span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bLen; ++i) &#123;</span><br><span class="line">        *p = b[i];</span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line">    *p = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">10</span>] = <span class="string">"123"</span>;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">10</span>] = <span class="string">"456"</span>;</span><br><span class="line">    <span class="keyword">char</span> *str = strcat_m(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表逆序"><a href="#链表逆序" class="headerlink" title="链表逆序"></a>链表逆序</h2><p>这个是对链表操作的基础的考察。</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Node* head;</span><br><span class="line">&#125; LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">helper</span><span class="params">(Node* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Node* n = p-&gt;next;</span><br><span class="line">        n = helper(n);</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            n-&gt;next = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(LinkedList* li)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* head = li-&gt;head;</span><br><span class="line">    Node* h = head;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (h-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            h = h-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* last = helper(head);</span><br><span class="line">        last-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    li-&gt;head = h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLinkedList</span><span class="params">(LinkedList* li)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* p = li-&gt;head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;ch);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkedList* li;</span><br><span class="line">    li-&gt;head = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    li-&gt;head-&gt;ch = <span class="string">'a'</span>;</span><br><span class="line">    li-&gt;head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    Node* p = li-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        Node* t = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        t-&gt;ch = <span class="string">'a'</span> + i;</span><br><span class="line">        t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;next = t;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    printLinkedList(li);</span><br><span class="line">    reverse(li);</span><br><span class="line">    printLinkedList(li);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码写完之后，我想到的是如果可以使用栈的话，只要先将所有节点压入栈，在弹出节点指针的过程中，先将第一个出栈的节点记录为头节点，之后依次链接，最后一个节点链接 <code>NULL</code>，这样程序的逻辑就会更加简单，缺点就是引入了额外的数据结构。</p><p>当然，上述的递归代码也是隐式地使用了函数调用栈。</p><p>如果使用三个指针的话，就可以不使用栈完成链表逆序。</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(LinkedList* li)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* prev = <span class="literal">NULL</span>, *cur = li-&gt;head, *next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cur-&gt;next = prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">        next = next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next = prev;</span><br><span class="line">    li-&gt;head = cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>这道题就是我觉得不应该出现在面试题中的题目。快排的话，会和不会都是在笔试之前就已经确定了的，并且并不太能体现处应试者的编程（算法）水平。毕竟，没有多少人会没事写个快排。</p><p>虽说如此，还是写了。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="keyword">int</span> beg, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = beg;</span><br><span class="line">    ++beg;</span><br><span class="line">    <span class="keyword">while</span> (beg &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (vec[beg] &lt;= vec[p] &amp;&amp; beg &lt;= end) &#123;</span><br><span class="line">            ++beg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (vec[end] &gt;= vec[p] &amp;&amp; end &gt;= beg) &#123;</span><br><span class="line">            --end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (beg &gt;= end) <span class="keyword">break</span>;</span><br><span class="line">        swap(vec[beg], vec[end]);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(vec[p], vec[end]);</span><br><span class="line">    <span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="keyword">int</span> beg, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beg &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p = partition(vec, beg, end);</span><br><span class="line">    helper(vec, beg, p<span class="number">-1</span>);</span><br><span class="line">    helper(vec, p+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    helper(vec, <span class="number">0</span>, vec.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVec</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;v : vec) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span> ,<span class="number">3</span>&#125;;</span><br><span class="line">    printVec(vec);</span><br><span class="line">    quicksort(vec);</span><br><span class="line">    printVec(vec);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本的步骤就是三步：</p><ol><li>切分</li><li>递归排序前半部分</li><li>递归排序后半部分</li></ol><p>最后，需要注意递归终止的条件。</p><p>这三步中最重要的就是切分这一步。</p><h2 id="要求打印出汉诺塔的移动序列"><a href="#要求打印出汉诺塔的移动序列" class="headerlink" title="要求打印出汉诺塔的移动序列"></a>要求打印出汉诺塔的移动序列</h2><p>最初接触到这道题是我大二开始学习计算机算法最初接触递归的时候。再次碰到的时候只考虑到了移动次数，内心觉得移动序列可能比较麻烦，就没再考虑。笔试时也没有多加思考就放弃了。</p><p>在回宿舍的路上大致想明白了思路：</p><ol><li>递归打印 <code>N-1</code></li><li>打印 <code>N</code></li><li>递归打印 <code>N-1</code></li></ol><p>没有考虑到的是需要将 <code>A B C</code> 三个柱子看作三个区域，目标是将整个汉诺塔依照要求从 <code>A</code> 移动到 <code>C</code>。这就需要考虑每一步移动时将 <code>A B C</code> 分别看作是 <code>源(from)</code>、<code>缓冲区(buffer)</code> 和 <code>目的(to)</code>。这部分参考 <a href="https://zh.wikipedia.org/zh-hans/%E6%B1%89%E8%AF%BA%E5%A1%94#%E9%81%9E%E8%BF%B4%E8%A7%A3" target="_blank" rel="noopener">wiki</a>。</p><p>思路：</p><ol><li>递归将 <code>N-1</code> 从 <code>from</code> 以 <code>to</code> 为缓冲区移动到 <code>buffer</code></li><li>将 <code>N</code> 从 <code>from</code> 移动到 <code>to</code></li><li>递归将 <code>N-1</code> 从 <code>buffer</code> 以 <code>from</code> 为缓冲区移动到 <code>to</code></li></ol><p>关键代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">helper(N<span class="number">-1</span>, from, to, buffer);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Move disk %d from %c to %c\n"</span>, N, from, to);</span><br><span class="line">helper(N<span class="number">-1</span>, buffer, from, to);</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">char</span> from, <span class="keyword">char</span> buffer, <span class="keyword">char</span> to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    helper(N<span class="number">-1</span>, from, to, buffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Move disk %d from %c to %c\n"</span>, N, from, to);</span><br><span class="line">    helper(N<span class="number">-1</span>, buffer, from, to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hannoi</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    helper(N, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print_hannoi(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    print_hannoi(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    print_hannoi(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第一次笔试没经验。我的基础能力也还是不足。离开电脑写代码，水平就开始极速下降了。</p><p>这家公司的 C/C++ 工程师的 4 道笔试题中有三道是需要用到递归实现的……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天参加了学校的一个企业实习的宣讲会，结束后做了笔试题。签到时我选择的应聘岗位是后端开发，但是在选择笔试试卷是选择了 C/C++ 开发。和编程相关的题目总共是 4 道题。现场做题的时候有很多的细节没有考虑到，而且我更习惯使用电脑写代码，没有多少在纸上写代码的经历，最后只写了 3 道，一道空白。就个人感觉，这些笔试题中有一道题并不适合笔试。最后，最重要的是很基础的题目我并没有能够做到 bug-free。编程的基础还需要继续巩固。特记录如下。&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="http://knothhe.github.io/blog/categories/Programming/"/>
    
    
      <category term="Interview" scheme="http://knothhe.github.io/blog/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX Beamer 使用</title>
    <link href="http://knothhe.github.io/blog/use-latex-beamer/"/>
    <id>http://knothhe.github.io/blog/use-latex-beamer/</id>
    <published>2019-04-13T12:25:25.000Z</published>
    <updated>2019-05-13T12:25:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天用了 Beamer 做一个 Presentation，花了一点时间在查找各种细节。 Presentation 已经基本完成。于是决定把折腾得到的结果记录一下。</p><p>以下均是一个 <code>LaTeX</code> 门外汉的个人见解，也只是知其然而不知其所以然罢了。</p><p>最终的 <a href="https://github.com/KnothHe/Markup-Files/blob/master/beamer/c51-beamer.tex" target="_blank" rel="noopener">Presentation</a></p><a id="more"></a><h2 id="元信息"><a href="#元信息" class="headerlink" title="元信息"></a>元信息</h2><p>可以添加一些作者，日期之类的信息。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">title</span><span class="string">&#123;..&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">author</span><span class="string">&#123;...&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">data</span><span class="string">&#123;...&#125;</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="标题页"><a href="#标题页" class="headerlink" title="标题页"></a>标题页</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;frame&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">titlepage</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;frame&#125;</span></span></span><br></pre></td></tr></table></figure><h2 id="生成-ToC"><a href="#生成-ToC" class="headerlink" title="生成 ToC"></a>生成 ToC</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;frame&#125;</span><span class="string">&#123;Table of Contents&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">tableofcontents</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;frame&#125;</span></span></span><br></pre></td></tr></table></figure><h2 id="Frame-标题"><a href="#Frame-标题" class="headerlink" title="Frame 标题"></a>Frame 标题</h2><p>在 <code>frame</code> 后加上 <code>{title}</code> 就行了。建议每个 <code>frame</code> 都加上一个标题。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;frame&#125;</span><span class="string">&#123;Title of This Frame&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;frame&#125;</span></span></span><br></pre></td></tr></table></figure><h2 id="中文显示"><a href="#中文显示" class="headerlink" title="中文显示"></a>中文显示</h2><p>这个问题在我刚开始使用 <code>LaTeX</code> 是还是挺犯难的，用的时间较长了，加上多年来 <code>LaTeX</code> 的发展， LaTeX 对非西文字体的支持已经发展的相对友好，解决方法已经变得相当的简单。</p><p>简单的解决方法就是使用 xeCJK，并配置中文字体。参考 <a href="https://liam.page/2014/11/02/latex-mactex-chinese-support/" target="_blank" rel="noopener">为 MacTeX 配置中文支持</a></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;xeCJK&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">setCJKmainfont</span><span class="string">[BoldFont=STZhongsong, ItalicFont=STKaiti]</span><span class="string">&#123;STSong&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">setCJKsansfont</span><span class="string">[BoldFont=STHeiti]</span><span class="string">&#123;STXihei&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">setCJKmonofont</span><span class="string">&#123;STFangsong&#125;</span></span></span><br></pre></td></tr></table></figure><p>中文字体可简单使用 <code>\usepackage{ctex}</code></p><p>并且对于中文等非西文字体的 <code>.tex</code> 源文件编译时，优先采用 <code>XeLaTeX</code>。毕竟原本 <code>XeTeX/XeLaTeX</code> 原本的设计目的就是增强对非西文字体的支持。</p><h2 id="Beamer-主题"><a href="#Beamer-主题" class="headerlink" title="Beamer 主题"></a>Beamer 主题</h2><p>我比较喜欢的主题是 <code>CambridgeUS</code></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usetheme</span><span class="string">&#123;CambridgeUS&#125;</span></span></span><br></pre></td></tr></table></figure><p>挑选 Beamer 内置主题的话，可以参考 <a href="https://hartwork.org/beamer-theme-matrix/" target="_blank" rel="noopener">Beamer Theem Matrix</a> 或者 <a href="https://mpetroff.net/files/beamer-theme-matrix/" target="_blank" rel="noopener">Another Beamer Theme Matrix</a> </p><p>当然，在主题之上还可以修改 <code>colortheme</code> 之类的。我挺喜欢正在使用的主题的默认的 <code>colortheme</code> 的，也就没改。</p><h2 id="划分章节"><a href="#划分章节" class="headerlink" title="划分章节"></a>划分章节</h2><p>和普通的 <code>LaTeX</code> 文档类似，可以为 <code>Beamer</code> 添加章节信息。章节信息最后会用于生成目录。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">section</span><span class="string">&#123;...&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">subsection</span><span class="string">&#123;...&#125;</span></span></span><br></pre></td></tr></table></figure><h2 id="代码排版"><a href="#代码排版" class="headerlink" title="代码排版"></a>代码排版</h2><p>在一个 <code>frame</code> 中排版代码也是可以的，借助 <code>listings</code> 宏包的解决方法如下：</p><p>下面这一部分可定义也可不定义，参考（复制于） <a href="https://en.wikibooks.org/wiki/LaTeX/Source_Code_Listings" target="_blank" rel="noopener">WikiBooks</a></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;color&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">definecolor</span><span class="string">&#123;mygreen&#125;</span><span class="string">&#123;rgb&#125;</span><span class="string">&#123;0,0.6,0&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">definecolor</span><span class="string">&#123;mygray&#125;</span><span class="string">&#123;rgb&#125;</span><span class="string">&#123;0.5,0.5,0.5&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">definecolor</span><span class="string">&#123;mymauve&#125;</span><span class="string">&#123;rgb&#125;</span><span class="string">&#123;0.58,0,0.82&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">lstset</span><span class="string">&#123; </span></span></span><br><span class="line"><span class="tag"><span class="string">    backgroundcolor=\color&#123;white&#125;</span></span>,   <span class="comment">% choose the background color; you must add \usepackage&#123;color&#125; or \usepackage&#123;xcolor&#125;; should come as last argument</span></span><br><span class="line">    basicstyle=<span class="tag">\<span class="name">ttfamily</span></span><span class="tag">\<span class="name">footnotesize</span></span>,        <span class="comment">% the size of the fonts that are used for the code</span></span><br><span class="line">    breakatwhitespace=true,         <span class="comment">% sets if automatic breaks should only happen at whitespace</span></span><br><span class="line">    breaklines=true,                 <span class="comment">% sets automatic line breaking</span></span><br><span class="line">    captionpos=b,                    <span class="comment">% sets the caption-position to bottom</span></span><br><span class="line">    commentstyle=<span class="tag">\<span class="name">color</span><span class="string">&#123;mygreen&#125;</span></span>,    <span class="comment">% comment style</span></span><br><span class="line">    deletekeywords=&#123;...&#125;,            <span class="comment">% if you want to delete keywords from the given language</span></span><br><span class="line">    escapeinside=&#123;<span class="tag">\<span class="name">%</span></span>*&#125;&#123;*)&#125;,          <span class="comment">% if you want to add LaTeX within your code</span></span><br><span class="line">    extendedchars=true,              <span class="comment">% lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8</span></span><br><span class="line">    frame=single,                   <span class="comment">% adds a frame around the code</span></span><br><span class="line">    keepspaces=false,                 <span class="comment">% keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)</span></span><br><span class="line">    morekeywords=&#123;bit, sbit, sfr, sfr16&#125;,            <span class="comment">% if you want to add more keywords to the set</span></span><br><span class="line">    keywordstyle=<span class="tag">\<span class="name">color</span><span class="string">&#123;blue&#125;</span></span>,       <span class="comment">% keyword style</span></span><br><span class="line">    language=C,                 <span class="comment">% the language of the code</span></span><br><span class="line">    numbers=left,                    <span class="comment">% where to put the line-numbers; possible values are (none, left, right)</span></span><br><span class="line">    numbersep=5pt,                   <span class="comment">% how far the line-numbers are from the code</span></span><br><span class="line">    numberstyle=<span class="tag">\<span class="name">tiny</span></span><span class="tag">\<span class="name">color</span><span class="string">&#123;mygray&#125;</span></span>, <span class="comment">% the style that is used for the line-numbers</span></span><br><span class="line">    rulecolor=<span class="tag">\<span class="name">color</span><span class="string">&#123;black&#125;</span></span>,         <span class="comment">% if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))</span></span><br><span class="line">    showspaces=false,                <span class="comment">% show spaces everywhere adding particular underscores; it overrides 'showstringspaces'</span></span><br><span class="line">    showstringspaces=false,          <span class="comment">% underline spaces within strings only</span></span><br><span class="line">    showtabs=false,                  <span class="comment">% show tabs within strings adding particular underscores</span></span><br><span class="line">    <span class="comment">%  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered</span></span><br><span class="line">    stringstyle=<span class="tag">\<span class="name">color</span><span class="string">&#123;mymauve&#125;</span></span>,     <span class="comment">% string literal style</span></span><br><span class="line">    tabsize=2,                 <span class="comment">% sets default tabsize to 2 spaces</span></span><br><span class="line">    title=<span class="tag">\<span class="name">lstname</span></span>                   <span class="comment">% show the filename of files included with \lstinputlisting; also try caption instead of title</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这部分参考 <a href="https://tex.stackexchange.com/questions/36776/latex-error-when-inserting-code-listing-in-lyx" target="_blank" rel="noopener">StackExchange</a>。</p><p>就是在需要排版代码的 <code>frame</code> 后加上参数 <code>fragile</code>。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;frame&#125;</span><span class="string">[fragile]</span></span></span><br><span class="line">    <span class="tag">\<span class="name">begin</span><span class="string">&#123;lstlisting&#125;</span><span class="string">[language=...]</span></span></span><br><span class="line">        <span class="comment">% ...</span></span><br><span class="line">        <span class="comment">% CODE</span></span><br><span class="line">        <span class="comment">% ...</span></span><br><span class="line">    <span class="tag">\<span class="name">end</span><span class="string">&#123;lstlisting&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;frame&#125;</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天用了 Beamer 做一个 Presentation，花了一点时间在查找各种细节。 Presentation 已经基本完成。于是决定把折腾得到的结果记录一下。&lt;/p&gt;
&lt;p&gt;以下均是一个 &lt;code&gt;LaTeX&lt;/code&gt; 门外汉的个人见解，也只是知其然而不知其所以然罢了。&lt;/p&gt;
&lt;p&gt;最终的 &lt;a href=&quot;https://github.com/KnothHe/Markup-Files/blob/master/beamer/c51-beamer.tex&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Presentation&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://knothhe.github.io/blog/categories/Tools/"/>
    
    
      <category term="LaTeX" scheme="http://knothhe.github.io/blog/tags/LaTeX/"/>
    
      <category term="Beamer" scheme="http://knothhe.github.io/blog/tags/Beamer/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 语法支持测试</title>
    <link href="http://knothhe.github.io/blog/markdown-syntax-support-test/"/>
    <id>http://knothhe.github.io/blog/markdown-syntax-support-test/</id>
    <published>2019-02-08T16:00:00.000Z</published>
    <updated>2019-07-18T08:47:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown 语法支持的测试博文，有关 Markdown 的语法可参考 <a href="https://www.markdownguide.org/basic-syntax" target="_blank" rel="noopener">Markdown Guide</a></p><a id="more"></a><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul><li><strong>粗体</strong></li><li><em>斜体</em></li><li><strong><em>粗体和斜体</em></strong></li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><ol><li>First item</li><li>Second item</li><li>Third item</li><li>Fourth item</li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p></blockquote><h2 id="代码块及代码高亮"><a href="#代码块及代码高亮" class="headerlink" title="代码块及代码高亮"></a>代码块及代码高亮</h2><h3 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><h3 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="转义标记"><a href="#转义标记" class="headerlink" title="转义标记"></a>转义标记</h2><p>比如　<code>LaTeX</code></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="有内容的链接"><a href="#有内容的链接" class="headerlink" title="有内容的链接"></a>有内容的链接</h3><p><a href="https://www.markdownguide.org/basic-syntax" target="_blank" rel="noopener">Markdown Guide</a></p><h3 id="无内容的链接-URL-和-Email"><a href="#无内容的链接-URL-和-Email" class="headerlink" title="无内容的链接(URL 和 Email)"></a>无内容的链接(URL 和 Email)</h3><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p><a href="https://knothhe.github.io/blog">https://knothhe.github.io/blog</a></p><h4 id="Email"><a href="#Email" class="headerlink" title="Email"></a>Email</h4><p><a href="mailto:&#x67;&#x75;&#x61;&#110;&#103;&#x6c;&#x61;&#x69;&#104;&#x65;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;" target="_blank" rel="noopener">&#x67;&#x75;&#x61;&#110;&#103;&#x6c;&#x61;&#x69;&#104;&#x65;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="/blog/markdown-syntax-support-test/qiao.jpg" alt="This is an image"></p><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><h3 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h3><p>质能方程：$E = mc^2$</p><h3 id="行间公式"><a href="#行间公式" class="headerlink" title="行间公式"></a>行间公式</h3><p>黎曼 $\zeta$ 函数</p><p>$$<br>    \zeta(s) = \sum_{n=1}^{\infty} \frac{1}{n^s}<br>$$</p><h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><p><a href="https://raw.githubusercontent.com/KnothHe/blog/master/source/_posts/markdown-syntax-support-test.md" target="_blank" rel="noopener">地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Markdown 语法支持的测试博文，有关 Markdown 的语法可参考 &lt;a href=&quot;https://www.markdownguide.org/basic-syntax&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Markdown Guide&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
